# 실습 예제

지금까지 배운 내용을 종합하여 실무와 유사한 문제를 풀어봅시다.

## 실습 데이터 구조

우리는 다음 테이블들을 사용합니다:

```sql
employees (직원)
- emp_id: 직원ID
- emp_name: 이름
- dept_id: 부서ID
- position: 직급
- salary: 급여
- hire_date: 입사일
- resign_date: 퇴사일 (NULL이면 재직중)

departments (부서)
- dept_id: 부서ID
- dept_name: 부서명

projects (프로젝트)
- project_id: 프로젝트ID
- project_name: 프로젝트명
- start_date: 시작일
- end_date: 종료일
- pl_emp_id: 프로젝트 리더 직원ID
```

## 기초 문제

### 문제 1: 재직 중인 직원 수
현재 재직 중인 직원이 몇 명인지 조회하세요.

<details>
<summary>힌트</summary>
재직 중 = resign_date가 NULL
</details>

<details>
<summary>정답</summary>

```sql
SELECT COUNT(*) AS 재직자수
FROM employees
WHERE resign_date IS NULL;
```
</details>

### 문제 2: 부서별 재직자 수
각 부서의 재직 중인 직원 수를 조회하세요. 부서명도 함께 표시하세요.

<details>
<summary>힌트</summary>
departments와 JOIN 필요, GROUP BY 사용
</details>

<details>
<summary>정답</summary>

```sql
SELECT
    d.dept_name AS 부서명,
    COUNT(e.emp_id) AS 재직자수
FROM departments d
LEFT JOIN employees e
    ON d.dept_id = e.dept_id
    AND e.resign_date IS NULL
GROUP BY d.dept_id, d.dept_name
ORDER BY 재직자수 DESC;
```
</details>

## 중급 문제

### 문제 3: 급여 상위 10명
급여가 높은 순서대로 상위 10명의 이름, 부서, 직급, 급여를 조회하세요.

<details>
<summary>정답</summary>

```sql
SELECT
    e.emp_name AS 이름,
    d.dept_name AS 부서,
    e.position AS 직급,
    e.salary AS 급여
FROM employees e
INNER JOIN departments d
    ON e.dept_id = d.dept_id
WHERE e.resign_date IS NULL
ORDER BY e.salary DESC
LIMIT 10;
```
</details>

### 문제 4: 부서별 평균 급여 (재직자만)
각 부서의 평균 급여를 조회하되, 재직 중인 직원만 대상으로 하세요.
평균 급여가 높은 순으로 정렬하세요.

<details>
<summary>정답</summary>

```sql
SELECT
    d.dept_name AS 부서명,
    COUNT(e.emp_id) AS 인원수,
    AVG(e.salary) AS 평균급여,
    MIN(e.salary) AS 최저급여,
    MAX(e.salary) AS 최고급여
FROM departments d
LEFT JOIN employees e
    ON d.dept_id = e.dept_id
    AND e.resign_date IS NULL
GROUP BY d.dept_id, d.dept_name
HAVING COUNT(e.emp_id) > 0
ORDER BY 평균급여 DESC;
```
</details>

### 문제 5: 입사 연도별 통계
입사 연도별로 몇 명이 입사했는지 조회하세요.
현재 재직 중인 사람과 퇴사한 사람을 구분하여 표시하세요.

<details>
<summary>정답</summary>

```sql
SELECT
    EXTRACT(YEAR FROM hire_date) AS 입사연도,
    COUNT(*) AS 전체,
    COUNT(CASE WHEN resign_date IS NULL THEN 1 END) AS 재직중,
    COUNT(CASE WHEN resign_date IS NOT NULL THEN 1 END) AS 퇴사
FROM employees
GROUP BY EXTRACT(YEAR FROM hire_date)
ORDER BY 입사연도 DESC;
```
</details>

## 고급 문제

### 문제 6: 프로젝트 리더 정보
각 프로젝트의 이름, 기간, PL의 이름과 부서를 조회하세요.

<details>
<summary>정답</summary>

```sql
SELECT
    p.project_name AS 프로젝트명,
    p.start_date AS 시작일,
    p.end_date AS 종료일,
    e.emp_name AS PL이름,
    d.dept_name AS PL부서
FROM projects p
LEFT JOIN employees e
    ON p.pl_emp_id = e.emp_id
LEFT JOIN departments d
    ON e.dept_id = d.dept_id
ORDER BY p.start_date DESC;
```
</details>

### 문제 7: 부서별 직급 분포
각 부서의 직급별 인원 수를 조회하세요. (재직자만)

<details>
<summary>정답</summary>

```sql
SELECT
    d.dept_name AS 부서,
    e.position AS 직급,
    COUNT(*) AS 인원수
FROM departments d
INNER JOIN employees e
    ON d.dept_id = e.dept_id
WHERE e.resign_date IS NULL
GROUP BY d.dept_name, e.position
ORDER BY d.dept_name, e.position;
```
</details>

### 문제 8: 재직 기간별 분포
재직 기간을 기준으로 직원을 분류하고, 각 그룹의 인원 수와 평균 급여를 조회하세요.
- 1년 미만
- 1년 이상 3년 미만
- 3년 이상 5년 미만
- 5년 이상

<details>
<summary>정답</summary>

```sql
SELECT
    CASE
        WHEN CURRENT_DATE - hire_date < 365 THEN '1년 미만'
        WHEN CURRENT_DATE - hire_date < 365 * 3 THEN '1-3년'
        WHEN CURRENT_DATE - hire_date < 365 * 5 THEN '3-5년'
        ELSE '5년 이상'
    END AS 재직기간,
    COUNT(*) AS 인원수,
    AVG(salary) AS 평균급여
FROM employees
WHERE resign_date IS NULL
GROUP BY
    CASE
        WHEN CURRENT_DATE - hire_date < 365 THEN '1년 미만'
        WHEN CURRENT_DATE - hire_date < 365 * 3 THEN '1-3년'
        WHEN CURRENT_DATE - hire_date < 365 * 5 THEN '3-5년'
        ELSE '5년 이상'
    END
ORDER BY 평균급여 DESC;
```
</details>

## 실무 시나리오

### 시나리오 1: 인사 보고서
CEO가 다음 정보를 요청했습니다:
"각 부서의 인원 현황, 평균 재직 기간, 급여 총액을 보고해주세요."

<details>
<summary>정답</summary>

```sql
SELECT
    d.dept_name AS 부서,
    COUNT(e.emp_id) AS 재직인원,
    ROUND(AVG(CURRENT_DATE - e.hire_date)) AS 평균재직일수,
    SUM(e.salary) AS 월급여총액,
    SUM(e.salary) * 12 AS 연급여총액
FROM departments d
LEFT JOIN employees e
    ON d.dept_id = e.dept_id
    AND e.resign_date IS NULL
GROUP BY d.dept_id, d.dept_name
ORDER BY 재직인원 DESC;
```
</details>

### 시나리오 2: 급여 인상 대상
다음 조건을 만족하는 직원 목록을 조회하세요:
- 재직 기간 3년 이상
- 현재 급여 6,000,000 미만
- 재직 중

<details>
<summary>정답</summary>

```sql
SELECT
    e.emp_name AS 이름,
    d.dept_name AS 부서,
    e.position AS 직급,
    e.salary AS 현재급여,
    ROUND((CURRENT_DATE - e.hire_date) / 365.0, 1) AS 재직년수
FROM employees e
INNER JOIN departments d
    ON e.dept_id = d.dept_id
WHERE e.resign_date IS NULL
    AND e.salary < 6000000
    AND CURRENT_DATE - e.hire_date >= 365 * 3
ORDER BY 재직년수 DESC, e.salary;
```
</details>

### 시나리오 3: 진행 중인 프로젝트 현황
현재 진행 중인 프로젝트(종료일이 오늘 이후)의 정보와 PL의 현재 업무량(담당 프로젝트 수)을 조회하세요.

<details>
<summary>정답</summary>

```sql
WITH pl_workload AS (
    SELECT
        pl_emp_id,
        COUNT(*) as project_count
    FROM projects
    WHERE end_date >= CURRENT_DATE
    GROUP BY pl_emp_id
)
SELECT
    p.project_name AS 프로젝트명,
    p.start_date AS 시작일,
    p.end_date AS 종료일,
    e.emp_name AS PL이름,
    d.dept_name AS 부서,
    w.project_count AS 담당프로젝트수
FROM projects p
LEFT JOIN employees e ON p.pl_emp_id = e.emp_id
LEFT JOIN departments d ON e.dept_id = d.dept_id
LEFT JOIN pl_workload w ON e.emp_id = w.pl_emp_id
WHERE p.end_date >= CURRENT_DATE
ORDER BY p.end_date, w.project_count DESC;
```
</details>

## 도전 문제

### 문제 9: 부서 이동 이력
(이 문제는 employee_history 테이블이 있다고 가정)
각 직원의 부서 이동 횟수를 조회하세요.

### 문제 10: 코호트 분석
입사 연도별로, 각 연도에 입사한 직원의 n년차 유지율을 계산하세요.

## 자유 연습

이제 실제 회사 데이터베이스에 접속하여:
1. 어떤 테이블들이 있는지 확인하세요
2. 각 테이블의 구조를 살펴보세요
3. 위 문제들을 실제 데이터에 맞게 변형하여 실행해보세요

## 다음 단계

SQL 기초를 완료했습니다! 🎉

이제 AI와 함께 SQL을 작성하는 방법을 배워봅시다.

👉 **[AI 활용 가이드로 이동](../03-AI-Usage/)**
