# 질문 예시 모음

실무에서 자주 사용하는 AI 질문 패턴과 예시입니다.

## SQL 작성 요청

### 패턴 1: 기본 조회

```
"[테이블명] 테이블에서 [조건]을 만족하는 데이터를 조회하는 SQL을 작성해줘.

테이블 구조:
- [컬럼 정보]

조건:
- [조건1]
- [조건2]"
```

**실제 예시:**
```
"employees 테이블에서 개발팀 소속이면서 급여가 6백만원 이상인
직원의 이름, 직급, 급여를 조회하는 SQL을 작성해줘.

테이블 구조:
- emp_id (직원ID)
- emp_name (이름)
- department (부서)
- position (직급)
- salary (급여)

조건:
- department = '개발팀'
- salary >= 6000000
- 급여 높은 순으로 정렬"
```

### 패턴 2: 집계 및 통계

```
"[테이블명]에서 [그룹 기준]별로 [집계 내용]을 조회하는 SQL을 작성해줘."
```

**실제 예시:**
```
"employees 테이블에서 부서별로 인원 수, 평균 급여, 최고 급여를 조회하는 SQL을 작성해줘.
부서명도 함께 표시하고, 인원 수가 10명 이상인 부서만 보고 싶어.

employees 테이블:
- emp_id, emp_name, dept_id, salary

departments 테이블:
- dept_id, dept_name"
```

### 패턴 3: JOIN 쿼리

```
"[테이블1]과 [테이블2]를 연결하여 [원하는 결과]를 조회하는 SQL을 작성해줘."
```

**실제 예시:**
```
"employees와 projects 테이블을 연결하여,
각 직원이 담당하는 프로젝트 목록을 조회하고 싶어.
프로젝트가 없는 직원도 포함해서 보고 싶어.

employees: emp_id, emp_name, dept_id
projects: project_id, project_name, emp_id (담당자)"
```

## 오류 해결

### 패턴: 오류 디버깅

```
"다음 SQL을 실행했을 때 [오류 메시지]가 발생했어.
무엇이 문제이고 어떻게 수정해야 할까?

[쿼리]

[오류 메시지]

테이블 구조:
[구조 정보]"
```

**실제 예시 1: GROUP BY 오류**
```
다음 SQL 실행 시 오류가 발생했습니다.

SELECT emp_name, department, AVG(salary)
FROM employees;

오류: column "emp_name" must appear in GROUP BY clause or be used in an aggregate function

무엇이 문제이고 어떻게 수정해야 할까요?
```

**실제 예시 2: JOIN 오류**
```
다음 쿼리가 예상과 다른 결과를 반환합니다.

SELECT e.emp_name, d.dept_name
FROM employees e, departments d;

결과가 너무 많이 나와요 (1000명 직원 * 10개 부서 = 10000 행).
각 직원의 소속 부서만 보고 싶은데 어떻게 수정해야 할까요?

employees: emp_id, emp_name, dept_id
departments: dept_id, dept_name
```

## 쿼리 최적화

### 패턴: 성능 개선

```
"다음 쿼리가 느린데, 어떻게 최적화할 수 있을까?

[쿼리]

추가 정보:
- 데이터 건수: [건수]
- 인덱스: [인덱스 정보]
- 실행 시간: [시간]"
```

**실제 예시:**
```
다음 쿼리가 10초 이상 걸립니다. 최적화 방법을 알려주세요.

SELECT *
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.hire_date >= '2020-01-01'
ORDER BY e.hire_date;

추가 정보:
- employees: 10만 건
- departments: 20개
- hire_date에 인덱스 없음"
```

## 쿼리 이해 및 학습

### 패턴 1: 쿼리 설명 요청

```
"다음 쿼리가 정확히 어떻게 작동하는지 단계별로 설명해줘.

[쿼리]"
```

**실제 예시:**
```
다음 쿼리가 정확히 어떻게 작동하는지 단계별로 설명해줘.

SELECT d.dept_name, COUNT(e.emp_id) as cnt
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id AND e.resign_date IS NULL
GROUP BY d.dept_id, d.dept_name
HAVING COUNT(e.emp_id) > 0
ORDER BY cnt DESC;
```

### 패턴 2: 비교 및 차이점

```
"다음 두 쿼리의 차이점과 각각 언제 사용해야 하는지 설명해줘.

[쿼리 1]

[쿼리 2]"
```

**실제 예시:**
```
다음 두 쿼리의 차이점을 설명해줘.

-- 쿼리 1
SELECT e.emp_name, d.dept_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.dept_id;

-- 쿼리 2
SELECT e.emp_name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

결과가 어떻게 다르고, 각각 언제 사용해야 할까?
```

## 실무 시나리오

### 시나리오 1: 보고서 작성

```
"월간 인사 보고서를 만들고 싶어. 다음 정보를 포함하는 SQL을 작성해줘:

1. 이번 달 입사자 수
2. 이번 달 퇴사자 수
3. 부서별 재직 인원
4. 부서별 평균 재직 기간

테이블:
employees: emp_id, emp_name, dept_id, hire_date, resign_date
departments: dept_id, dept_name"
```

### 시나리오 2: 데이터 검증

```
"데이터 정합성을 확인하고 싶어. 다음을 체크하는 SQL을 작성해줘:

1. 부서 ID가 있는데 departments 테이블에 없는 직원
2. 입사일이 퇴사일보다 늦은 직원
3. NULL이 있으면 안 되는 필수 컬럼에 NULL이 있는 직원"
```

### 시나리오 3: 예측 및 분석

```
"다음 월에 계약 만료되는 프로젝트 목록과,
해당 프로젝트에 투입된 인원 수를 조회하고 싶어.

projects: project_id, project_name, start_date, end_date
project_members: project_id, emp_id, role"
```

## 프롬프트 작성 팁

### ✅ DO (해야 할 것)

1. **구체적으로**
   ```
   ❌ "데이터 조회해줘"
   ✅ "employees 테이블에서 2023년 입사자의 부서별 인원 수를 조회해줘"
   ```

2. **컨텍스트 제공**
   ```
   ❌ "이 쿼리 고쳐줘"
   ✅ "이 쿼리를 실행하면 [오류]가 나. 테이블 구조는 [...]이고, [...]를 조회하려고 해"
   ```

3. **단계별로**
   ```
   ❌ "복잡한 통계 리포트 한 번에 만들어줘"
   ✅ "먼저 기본 집계부터 하고, 그 다음 세부 조건 추가할게"
   ```

### ❌ DON'T (하지 말아야 할 것)

1. **모호한 질문**
   ```
   ❌ "SQL 알려줘"
   ❌ "이거 왜 안돼?"
   ❌ "도와줘"
   ```

2. **컨텍스트 없이**
   ```
   ❌ [쿼리만 던지고] "고쳐줘"
   ```

3. **너무 많은 요구사항을 한 번에**
   ```
   ❌ "이것도 하고 저것도 하고 그것도 하고..." (10개 요구사항)
   ```

## 다음 단계

다양한 질문 예시를 살펴봤다면, 이제 효과적인 프롬프트 작성 기술을 배워봅시다!

👉 **[프롬프트 작성 팁으로 이동](./프롬프트-작성-팁.md)**
